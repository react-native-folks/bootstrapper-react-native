import { isFulfilled } from '@reduxjs/toolkit';
import { GenericFetchInitialState } from 'interfaces/redux';
import { createFetchSlice } from 'redux/utils';

import actionCreators, { actionsTypes } from './actions';

interface AuthState {
  initialLoading: boolean;
  <%_ if(features.loginandsignup) { _%>
  currentUser: any;
  <%_ } _%> 
  <%_ if(features.onboarding) { _%>
  hasAccessOnBoarding: boolean;
  <%_ } _%>
}

export const initialState: GenericFetchInitialState<AuthState> = {
  initialLoading: true,
  <%_ if(features.loginandsignup) { _%>
  currentUser: null,
  <%_ } _%>
  <%_ if(features.onboarding) { _%>
  hasAccessOnBoarding: false,
  <%_ } _%>
  <%_ if(features.onboarding || loginandsignup) { _%>
  loading: false,
  error: null
  <%_ } _%>
};

const authSlice = createFetchSlice({
  name: actionsTypes.namespace,
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(actionCreators.init.fulfilled, state => {
        state.initialLoading = false;
      })
      <%_ if(features.onboarding) { _%>
      .addMatcher(
        isFulfilled(actionCreators.init, actionCreators.setHasAccessOnBoarding),
        (state, action) => {
          state.hasAccessOnBoarding = action.payload.hasAccessOnBoarding;
        }
      )
      <%_ } _%>
      <%_ if(features.loginandsignup) { _%>
      .addMatcher(
        isFulfilled(
          actionCreators.init,
          actionCreators.login,
          actionCreators.logout
        ),
        (state, action) => {
          state.currentUser = action.payload.currentUser;
        }
      )
      <%_ } _%>
  }
});

export default authSlice;
